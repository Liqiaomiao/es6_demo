<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<pre>
    钩子函数：
    当我们在操作一个对象或者方法时会有几种动作，比如：在运行函数前初始化一些数据，在改变对象值后做一些善后处理。
    这些都算钩子函数，Proxy的存在就可以让我们给函数加上这样的钩子函数，你也可以理解为在执行方法前预处理一些代码。
    你可以简单的理解为他是函数或者对象的生命周期。
    Proxy的应用可以使函数更加强大，业务逻辑更加清楚，而且在编写自己的框架或者通用组件时非常好用。
    我们用new的方法对Proxy进行声明
    new Proxy（{},{}）;
    第一个花括号就相当于我们方法的主体，后边的花括号就是Proxy代理处理区域，相当于我们写钩子函数的地方。
    new Proxy（{
    },{
        get:function(target,key,property){
            //target：得到的目标对象
            //key:目标的key，相当于对象的属性
        }
    }）;



</pre>
<ol>
    <li>拦截和监视外部对对象的访问</li>
    <li>降低函数或类的复杂度</li>
    <li>在复杂操作前对操作进行校验或对所需资源进行管理</li>
</ol>
<dl>
    <dt>应用场景</dt>
    <dd>
        <ol>
            <li>
                抽离校验模块
            </li>
            <li>私有属性
                <p>第一种方法是使用 set / get 拦截读写请求并返回 undefined
                   </p>
                <p>第二种方法是使用 has 拦截 in 操作</p>
            </li>
            <li>访问日志:
                <p>对于那些调用频繁、运行缓慢或占用执行环境资源较多的属性或接口，开发者会希望记录它们的使用情况或性能表现，这个时候就可以使用 Proxy 充当中间件的角色，轻而易举实现日志功能
                </p>
            </li>
            <li>预警和拦截</li>
            <li>过滤操作</li>
            <li>中断代理 Proxy.revocable</li>
        </ol>
    </dd>
</dl>
<script src="../dist/用Proxy进行预处理.js"></script>
</body>
</html>